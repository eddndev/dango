---
interface Props {
  direction?: "left" | "right";
  speed?: number;
}

const { direction = "left", speed = 30 } = Astro.props;

// Icon names M1.svg to M20.svg
const iconNames = Array.from({ length: 18 }, (_, i) => `M${i + 1}.svg`);

// Duplicate for seamless loop (4 sets to ensure viewport coverage)
// Set 1: Initial view
// Set 2: Seamless transition target
// Set 3 & 4: Buffer for large screens
const displayIcons = [...iconNames, ...iconNames, ...iconNames, ...iconNames];
---

<div class="slider-container" data-direction={direction}>
  <div class="slider-track">
    {
      displayIcons.map((icon) => (
        <div class="slider-item">
          <img src={`/icons/${icon}`} alt="Festival Icon" class="icon-img" />
        </div>
      ))
    }
  </div>
</div>

<script>
  import { gsap } from "gsap";

  document.addEventListener("astro:page-load", () => {
    initSliders();
  });

  // Re-run on resize to recalculate widths
  window.addEventListener("resize", () => {
    initSliders();
  });

  function initSliders() {
    const sliders = document.querySelectorAll(".slider-container");

    sliders.forEach((container) => {
      const direction = container.getAttribute("data-direction");
      const track = container.querySelector(".slider-track") as HTMLElement;

      if (!track) return;

      // Kill existing tweens to prevent conflicts
      gsap.killTweensOf(track);

      const items = track.querySelectorAll(".slider-item");
      if (items.length === 0) return;

      // Robust width calculation with retry
      const measureAndAnimate = (attempts = 0) => {
        const firstItemWidth = (items[0] as HTMLElement).getBoundingClientRect()
          .width;

        if (firstItemWidth === 0 && attempts < 10) {
          // If width is 0, wait and retry (layout might not be ready)
          setTimeout(() => measureAndAnimate(attempts + 1), 100);
          return;
        }

        // Calculate total width of one set (variable widths)
        const singleSetCount = items.length / 4;
        let singleSetWidth = 0;

        // Sum widths including gap/margin
        for (let i = 0; i < singleSetCount; i++) {
          const rect = (items[i] as HTMLElement).getBoundingClientRect();
          singleSetWidth += rect.width;
          // margin removed
        }

        // Use a fixed speed (pixels per second)
        const speed = 50;
        const duration = singleSetWidth / speed;

        if (direction === "right") {
          gsap.fromTo(
            track,
            { x: -singleSetWidth },
            {
              x: 0,
              duration: duration,
              ease: "none",
              repeat: -1,
            },
          );
        } else {
          gsap.fromTo(
            track,
            { x: 0 },
            {
              x: -singleSetWidth,
              duration: duration,
              ease: "none",
              repeat: -1,
            },
          );
        }
      };

      // Start measurement
      measureAndAnimate();
    });
  }
</script>

<style>
  .slider-container {
    width: 100%;
    overflow: hidden;
    position: relative;
    height: 40px;
    background: transparent;
  }

  .slider-track {
    display: flex;
    align-items: center;
    width: max-content;
    will-change: transform;
    height: 100%;
  }

  .slider-item {
    flex-shrink: 0;
    height: 40px; /* Consistent height */
    width: auto; /* Dynamic width */
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 0; /* Removed spacing */
  }

  .icon-img {
    width: auto;
    height: 100%;
    /* removed object-fit: contain since we want natural aspect ratio at fixed height */
  }
</style>
